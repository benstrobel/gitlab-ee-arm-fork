stages:
  - config

workflow:
  rules:
    # Do not create a pipeline on branch push to QA mirror
    - if: '$CI_PROJECT_NAME == "omnibus-gitlab-mirror" && $CI_PIPELINE_SOURCE == "push"'
      when: never
    # No pipeline on auto-deploy branches as a tag will definitely follow
    - if: '$CI_COMMIT_BRANCH =~ /^[0-9]+-[0-9]+-auto-deploy-[0-9]+$/'
      when: never
    # Set CACHE_EDITION variable to GITLAB for pipelines triggered from gitlab-org/gitlab project so that they don't pollute regular branch cache
    - if: '$TOP_UPSTREAM_SOURCE_PROJECT == "gitlab-org/gitlab"'
      variables:
        CACHE_EDITION: "GITLAB"
    # Set CACHE_EDITION variable to STABLE on stable branch pipelines so that they don't pollute regular branch cache
    - if: '$CI_COMMIT_BRANCH =~ /^.*-stable$/'
      variables:
        CACHE_EDITION: "STABLE"
    # Set CACHE_EDITION variable to EE on EE pipelines
    - if: '$ee == "true" || $GITLAB_VERSION =~ /^*-ee/ || $CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+\+[^ ]{7,}\.[^ ]{7,}$/ || $CI_COMMIT_TAG =~ /^.*ee\.\d.*$/ || $CI_COMMIT_BRANCH =~ /^.*-ee$/'
      variables:
        CACHE_EDITION: "EE"
    # For all other branches, create a pipeline. We are explicitly specifying
    # this so that this rule gets matched earlier before MR pipelines gets
    # triggered, thus causing two pipelines for a branch push - a regular one
    # and a detached one. If we ever decide not to run pipelines on branch
    # pushes that doesn't cause an MR, we can change the following to
    # $CI_MERGE_REQUEST_IID
    - if: '$CI_COMMIT_BRANCH'
      when: always
    # For tags, always create a pipeline.
    - if: '$CI_COMMIT_TAG'
      when: always

default:
  tags:
    - gitlab-org

variables:
  # BUILDER_IMAGE_REGISTRY is set to
  # `dev.gitlab.org:5005/cookbooks/gitlab-omnibus-builder` in the project
  # settings of omnibus-gitlab mirror in dev.gitlab.org so that builds there
  # will use images from that registry and not depend on GitLab.com
  BUILDER_IMAGE_REGISTRY: "registry.gitlab.com/gitlab-org/gitlab-omnibus-builder"
  PUBLIC_BUILDER_IMAGE_REGISTRY: "registry.gitlab.com/gitlab-org/gitlab-omnibus-builder"
  BUILDER_IMAGE_REVISION: "3.5.0"
  # The registry to pull the assets image from
  ASSET_REGISTRY: "${CI_REGISTRY}"
  ASSET_SYNC_EXISTING_REMOTE_FILES: "keep"
  ASSET_SYNC_GZIP_COMPRESSION: "true"
  ASSET_PATH: "assets-${CI_COMMIT_REF_SLUG}"
  COMPILE_ASSETS: "false"
  RUBY_IMAGE: "ruby:2.7"
  BUNDLE_PATH__SYSTEM: "false"
  # Format of the auto-deploy tag for auto-deploy builds.
  # https://gitlab.com/gitlab-org/release/docs/blob/master/general/deploy/auto-deploy.md#auto-deploy-tagging
  AUTO_DEPLOY_TAG_REGEX: '^\d+\.\d+\.\d+\+[^ ]{7,}\.[^ ]{7,}$'
  # Default environment for auto-deploy
  AUTO_DEPLOY_ENVIRONMENT: 'pre'
  OMNIBUS_GITLAB_MIRROR_ID: "14588374"
  DOCS_GITLAB_REPO_SUFFIX: "omnibus"
  CACHE_KEY_SUFFIX: '-v1'
  CACHE_EDITION: "CE"
  QA_BRANCH: 'master'
  ISSUE_BOT_LABELS_EXTRA: "group::distribution"
  BUNDLER_VERSION: "2.2.33"

before_script:
  - export CE_ONLY=(Raspberry)
  - export EE_ONLY=(SLES RAT)
  - for job in "${CE_ONLY[@]}"; do
      if [[ "${CI_JOB_NAME}" =~ ${job} ]]; then
        if ./support/is_gitlab_ee.sh; then
          echo "EE build found. ${CI_JOB_NAME} is run only on CE builds";
          exit 0 ;
        fi;
      fi;
    done
  - for job in "${EE_ONLY[@]}"; do
      if [[ "${CI_JOB_NAME}" =~ ${job} ]]; then
        if ! ./support/is_gitlab_ee.sh; then
          echo "CE build found. ${CI_JOB_NAME} is run only on EE builds";
          exit 0 ;
        fi;
      fi;
    done
  - echo $NIGHTLY
  - mkdir -p ~/.ssh
  - mkdir -p ~/.aws
  - mkdir -p cache
  - if [ -n "$DEV_GITLAB_SSH_KEY" ]; then
      echo "$DEV_GITLAB_SSH_KEY" > ~/.ssh/id_rsa;
      cp support/known_hosts ~/.ssh/known_hosts;
      chmod -R 0600 ~/.ssh/;
    fi
  - gem install bundler:${BUNDLER_VERSION}
  - bundle config set --local path 'gems'
  - bundle config set --local without 'rubocop'
  - if [ "$INCLUDE_PACKAGECLOUD" = "true" ]; then
      bundle config set --local with 'packagecloud';
    fi
  # If OMNIBUS_GEM_SOURCE is set, then check it out as a local override to the
  # omnibus gem. The local overide does not change the Gemfile.lock. As part of
  # the build pipeline, we are checking whether the state of the repository is
  # unchanged during the build process, by comparing it with the last commit
  # (So that no unexpected monsters show up). So, an altered Gemfile.lock file
  # would fail on this check. Using the local override avoids this. Bundler
  # will still validate and use the git revision specified in the Gemfile.lock
  # when using the local checkout.
  - if [ -n "${OMNIBUS_GEM_SOURCE}" ]; then
      git clone --branch "$(cat OMNIBUS_GEM_VERSION)" "${OMNIBUS_GEM_SOURCE}" .bundle/local-omnibus;
      bundle config --local local.omnibus .bundle/local-omnibus;
      bundle config --local disable_local_branch_check true;
    fi
  - bundle config set frozen 'true'
  - echo -e "section_start:`date +%s`:bundle_install[collapsed=true]\r\e[0Kbundle install -j $(nproc)"
  - bundle install -j $(nproc)
  - echo -e "section_end:`date +%s`:bundle_install\r\e[0K"
  - bundle binstubs --all
  - if [ -n "$NIGHTLY" ]; then export STAGING_REPO=nightly-builds; export FIPS_STAGING_REPO=nightly-fips-builds; fi

generate-config:
  stage: config
  image: "${BUILDER_IMAGE_REGISTRY}/ubuntu_20.04:${BUILDER_IMAGE_REVISION}"
  script:
    - bundle exec rake ci:generate_config
  artifacts:
    paths:
      - generated_ci_config.yml

child-pipeline:
  stage: config
  inherit:
    variables: true
  needs:
    - generate-config
  trigger:
    strategy: depend
    include:
      - artifact: generated_ci_config.yml
        job: generate-config
