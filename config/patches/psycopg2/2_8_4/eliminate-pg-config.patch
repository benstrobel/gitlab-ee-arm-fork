diff --git a/setup.cfg b/setup.cfg
index 43c61d16..ce07a79e 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -2,11 +2,6 @@
 # PSYCOPG_DEBUG can be added to enable verbose debug information
 define=
 
-# "pg_config" is required to locate PostgreSQL headers and libraries needed to
-# build psycopg2. If pg_config is not in the path or is installed under a
-# different name set the following option to the pg_config full path.
-pg_config=
-
 # If the build system does not find the mx.DateTime headers, try
 # setting its value to the right path.
 mx_include_dir=
@@ -22,5 +17,11 @@ static_libpq=0
 # Add here eventual extra libraries required to link the module.
 libraries=
 
+# Omnibus install directory
+install_dir=/opt/gitlab
+
+# PostgreSQL version
+pg_version=11
+
 [metadata]
 license_file = LICENSE
diff --git a/setup.py b/setup.py
index 8b8da110..f77974c4 100644
--- a/setup.py
+++ b/setup.py
@@ -81,136 +81,42 @@ version_flags = ['dt', 'dec']
 
 PLATFORM_IS_WINDOWS = sys.platform.lower().startswith('win')
 
+def exec_pg_ctl(cfg, args):
+    try:
+        pg_ctl_process = subprocess.Popen(
+            ['%s/embedded/postgresql/%s/bin/pg_ctl' % (cfg.install_dir, cfg.pg_version), args],
+            stdin=subprocess.PIPE,
+            stdout=subprocess.PIPE,
+            stderr=subprocess.PIPE)
+    except OSError as err:
+        raise Warning("Unable to find 'pg_ctl' file in '%s'" % cfg.install_dir)
+    pg_ctl_process.stdin.close()
+    result = pg_ctl_process.stdout.readline().strip()
+    if not result:
+        raise Warning(pg_ctl_process.stderr.readline())
+    if not isinstance(result, str):
+        result = result.decode('ascii')
+    return result
+
+OMNIBUS_PG_CONFIG = {
+    'libdir': lambda cfg: '%s/embedded/postgresql/%s/lib' % (cfg.install_dir, cfg.pg_version),
+    'includedir': lambda cfg: '%s/embedded/postgresql/%s/include' % (cfg.install_dir, cfg.pg_version),
+    'includedir-server': lambda cfg: '%s/embedded/postgresql/%s/include/server' % (cfg.install_dir, cfg.pg_version),
+    'version': lambda cfg: exec_pg_ctl(cfg, '--version')
+}
 
 class PostgresConfig:
     def __init__(self, build_ext):
         self.build_ext = build_ext
-        self.pg_config_exe = self.build_ext.pg_config
-        if not self.pg_config_exe:
-            self.pg_config_exe = self.autodetect_pg_config_path()
-        if self.pg_config_exe is None:
-            sys.stderr.write("""
-Error: pg_config executable not found.
-
-pg_config is required to build psycopg2 from source.  Please add the directory
-containing pg_config to the $PATH or specify the full executable path with the
-option:
-
-    python setup.py build_ext --pg-config /path/to/pg_config build ...
-
-or with the pg_config option in 'setup.cfg'.
-
-If you prefer to avoid building psycopg2 from source, please install the PyPI
-'psycopg2-binary' package instead.
-
-For further information please check the 'doc/src/install.rst' file (also at
-<http://initd.org/psycopg/docs/install.html>).
-
-""")
-            sys.exit(1)
+        self.install_dir = build_ext.install_dir
+        self.pg_version = build_ext.pg_version
 
     def query(self, attr_name):
-        """Spawn the pg_config executable, querying for the given config
-        name, and return the printed value, sanitized. """
-        try:
-            pg_config_process = subprocess.Popen(
-                [self.pg_config_exe, "--" + attr_name],
-                stdin=subprocess.PIPE,
-                stdout=subprocess.PIPE,
-                stderr=subprocess.PIPE)
-        except OSError:
-            raise Warning("Unable to find 'pg_config' file in '%s'" %
-                          self.pg_config_exe)
-        pg_config_process.stdin.close()
-        result = pg_config_process.stdout.readline().strip()
-        if not result:
-            raise Warning(pg_config_process.stderr.readline())
-        if not isinstance(result, str):
-            result = result.decode('ascii')
-        return result
-
-    def find_on_path(self, exename, path_directories=None):
-        if not path_directories:
-            path_directories = os.environ['PATH'].split(os.pathsep)
-        for dir_name in path_directories:
-            fullpath = os.path.join(dir_name, exename)
-            if os.path.isfile(fullpath):
-                return fullpath
-        return None
-
-    def autodetect_pg_config_path(self):
-        """Find and return the path to the pg_config executable."""
-        if PLATFORM_IS_WINDOWS:
-            return self.autodetect_pg_config_path_windows()
+        if attr_name in OMNIBUS_PG_CONFIG:
+            return OMNIBUS_PG_CONFIG[attr_name].__call__(self)
         else:
-            return self.find_on_path('pg_config')
-
-    def autodetect_pg_config_path_windows(self):
-        """Attempt several different ways of finding the pg_config
-        executable on Windows, and return its full path, if found."""
-
-        # This code only runs if they have not specified a pg_config option
-        # in the config file or via the commandline.
-
-        # First, check for pg_config.exe on the PATH, and use that if found.
-        pg_config_exe = self.find_on_path('pg_config.exe')
-        if pg_config_exe:
-            return pg_config_exe
-
-        # Now, try looking in the Windows Registry to find a PostgreSQL
-        # installation, and infer the path from that.
-        pg_config_exe = self._get_pg_config_from_registry()
-        if pg_config_exe:
-            return pg_config_exe
-
-        return None
-
-    def _get_pg_config_from_registry(self):
-        try:
-            import winreg
-        except ImportError:
-            import _winreg as winreg
-
-        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
-        try:
-            pg_inst_list_key = winreg.OpenKey(reg,
-                'SOFTWARE\\PostgreSQL\\Installations')
-        except EnvironmentError:
-            # No PostgreSQL installation, as best as we can tell.
             return None
 
-        try:
-            # Determine the name of the first subkey, if any:
-            try:
-                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)
-            except EnvironmentError:
-                return None
-
-            pg_first_inst_key = winreg.OpenKey(reg,
-                'SOFTWARE\\PostgreSQL\\Installations\\' + first_sub_key_name)
-            try:
-                pg_inst_base_dir = winreg.QueryValueEx(
-                    pg_first_inst_key, 'Base Directory')[0]
-            finally:
-                winreg.CloseKey(pg_first_inst_key)
-
-        finally:
-            winreg.CloseKey(pg_inst_list_key)
-
-        pg_config_path = os.path.join(
-            pg_inst_base_dir, 'bin', 'pg_config.exe')
-        if not os.path.exists(pg_config_path):
-            return None
-
-        # Support unicode paths, if this version of Python provides the
-        # necessary infrastructure:
-        if sys.version_info[0] < 3:
-            pg_config_path = pg_config_path.encode(
-                sys.getfilesystemencoding())
-
-        return pg_config_path
-
-
 class psycopg_build_ext(build_ext):
     """Conditionally complement the setup.cfg options file.
 
@@ -225,8 +131,10 @@ class psycopg_build_ext(build_ext):
     user_options.extend([
         ('use-pydatetime', None,
          "Use Python datatime objects for date and time representation."),
-        ('pg-config=', None,
-         "The name of the pg_config binary and/or full path to find it"),
+        ('install-dir=', None,
+         "PostgreSQL version"),
+        ('pg-version=', None,
+         "PostgreSQL version"),
         ('have-ssl', None,
          "Compile with OpenSSL built PostgreSQL libraries (Windows only)."),
         ('static-libpq', None,
@@ -245,7 +153,8 @@ class psycopg_build_ext(build_ext):
         self.mx_include_dir = None
         self.have_ssl = have_ssl
         self.static_libpq = static_libpq
-        self.pg_config = None
+        self.install_dir = install_dir
+        self.pg_version = pg_version
 
     def compiler_is_msvc(self):
         return self.get_compiler_name().lower().startswith('msvc')
@@ -412,7 +321,7 @@ For further information please check the 'doc/src/install.rst' file (also at
             self.library_dirs.append(pg_config_helper.query("libdir"))
             self.include_dirs.append(pg_config_helper.query("includedir"))
             self.include_dirs.append(pg_config_helper.query("includedir-server"))
-            pgversion = pg_config_helper.query("version").split()[1]
+            pgversion = pg_config_helper.query("version").split()[2]
 
             verre = re.compile(
                 r"(\d+)(?:\.(\d+))?(?:(?:\.(\d+))|(devel|(?:alpha|beta|rc)\d+))?")
@@ -561,6 +470,16 @@ if parser.has_option('build_ext', 'static_libpq'):
 else:
     static_libpq = False
 
+if parser.has_option('build_ext', 'install_dir'):
+    install_dir = parser.get('build_ext', 'install_dir')
+else:
+    install_dir = '/opt/gitlab'
+
+if parser.has_option('build_ext', 'pg_version'):
+    pg_version = parser.get('build_ext', 'pg_version')
+else:
+    pg_version = '11'
+
 # And now... explicitly add the defines from the .cfg files.
 # Looks like setuptools or some other cog doesn't add them to the command line
 # when called e.g. with "pip -e git+url'. This results in declarations
